<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>vmx on vUptime.io - Cloud builder(s)</title><link>vuptime.io/tags/vmx/</link><description>Recent content in vmx on vUptime.io - Cloud builder(s)</description><generator>Hugo -- gohugo.io</generator><copyright>Ludovic Rivallain and blog co-authors</copyright><lastBuildDate>Tue, 10 Feb 2015 00:00:00 +0000</lastBuildDate><atom:link href="vuptime.io/tags/vmx/feed.xml" rel="self" type="application/rss+xml"/><item><title>Nested VMware ESXi with virtualbox - Your first nested-virtual-machine</title><link>vuptime.io/post/2015-02-10-nested-vmware-esxi-virtualbox-your-first-nested-virtual-machine/</link><pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate><guid>/2015/02/10/nested-vmware-esxi-virtualbox-your-first-nested-virtual-machine/</guid><description>
&lt;p>Now that we've seen &lt;a href="vuptime.io/2015/01/25/nested-esxi-virtualbox/" title="Nested ESXi on Virtualbox">how to create a nested-ESXi&lt;/a> on virtualbox, we may need to have some content in order to test commands of procedures.&lt;/p>
&lt;h2 id="local-datastore">Local datastore&lt;/h2>
&lt;h3 id="disk-creation">Disk creation&lt;/h3>
&lt;p>To create a local datastore, you'll have to add a new virtual disk to your nested ESXi:&lt;/p>
&lt;p>First step is to create a SATA disk controller:&lt;/p>
&lt;figure>&lt;img src="vuptime.io/images/NestedVirtualMachine/NestedVirtualMachine01.png"/>&lt;figcaption>
&lt;h4>Add a SATA controller&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>Next, create a new disk on the SATA controller:&lt;/p>
&lt;figure>&lt;img src="vuptime.io/images/NestedVirtualMachine/NestedVirtualMachine02.png"/>&lt;figcaption>
&lt;h4>Add a new disk&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>I've choose to set:&lt;/p>
&lt;ul>
&lt;li>vmdk file type&lt;/li>
&lt;li>10GB&lt;/li>
&lt;li>Dynamic allocation&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="vuptime.io/images/NestedVirtualMachine/NestedVirtualMachine03.png"/>&lt;figcaption>
&lt;h4>My additional disk settings&lt;/h4>
&lt;/figcaption>
&lt;/figure>
&lt;p>When the vdisk is connected, ESXi started, get it's name before creating a VMFS file system. Name should be something close to &lt;code>_/dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VBxcxxxxxxxxxxxxxxx__&lt;/code>&lt;/p>
&lt;p>Here is a tip to only get un-partitionned disks locally connected to the ESXi:&lt;/p>
&lt;pre>&lt;code>$ fdisk -l | grep partition
Disk /dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__ doesn't contain a valid partition table
&lt;/code>&lt;/pre>
&lt;h3 id="disk-partition">Disk partition&lt;/h3>
&lt;p>When the new disk is located on the &lt;code>/dev/disks/&lt;/code>, check the partition table:&lt;/p>
&lt;pre>&lt;code>$ partedUtil get /dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VBbc7a87cf2D7739136a_
1305 255 63 20971520
&lt;/code>&lt;/pre>
&lt;p>This indicates that there is no partition on this disk and every sector is free space.&lt;/p>
&lt;p>We also need the number of sector on the disk. This information is the last number of the previous command: 20971520 here.&lt;/p>
&lt;p>Then we can create the first partition.&lt;/p>
&lt;pre>&lt;code>$ partedUtil set &amp;quot;/vmfs/devices/disks/t10.ATA_____VBOX_HARDDISK___________________________VBbc7a87cf2D7739136a_&amp;quot; &amp;quot;1 128 20971519 251 0&amp;quot;
0 0 0 0
1 128 20971519 251 0
&lt;/code>&lt;/pre>
&lt;p>In this example, we create a partition number 1, starting at sector 128 and ending at sector 20971519 (20971520-1), with type 251 = 0xFB.&lt;/p>
&lt;p>And we can check the result:&lt;/p>
&lt;pre>&lt;code>$ partedUtil get /dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VBbc7a87cf2D7739136a_
1305 255 63 20971520
1 128 20971519 251 0
&lt;/code>&lt;/pre>
&lt;p>Now we have a free partition ! And we can apply a vmfs5 file-system:&lt;/p>
&lt;pre>&lt;code>$ vmkfstools -C vmfs5 -b 1m -S LocalDatastore_001 /dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1
create fs deviceName:'/dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1', fsShortName:'vmfs5', fsName:'LocalDatastore_001'
deviceFullPath:/dev/disks/t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1 deviceFile:t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1
VMFS5 file system creation is deprecated on a BIOS/MBR partition on device 't10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1'
Checking if remote hosts are using this device as a valid file system. This may take a few seconds...
Creating vmfs5 file system on &amp;quot;t10.ATA_____VBOX_HARDDISK___________________________VB_VBxcxxxxxxxxxxxxxxx__:1&amp;quot; with blockSize 1048576 and volume label &amp;quot;LocalDatastore_001&amp;quot;.
Successfully created new volume: 54d15e2c-eeeeeeee-9cff-080027b1c126
&lt;/code>&lt;/pre>
&lt;p>In this case, we create a vmfs5 datastore, with &lt;code>LocalDatastore_001&lt;/code> name and 1Mb block size.&lt;/p>
&lt;p>And to check that datastore is ready:&lt;/p>
&lt;pre>&lt;code>$ esxcli storage filesystem list
Mount Point Volume Name UUID Mounted Type Size Free
------------------------------------------------- ------------------ ----------------------------------- ------- ------ ----------- ----------
/vmfs/volumes/54d15e2c-eeeeeeee-9cff-080027b1c126 LocalDatastore_001 54d15e2c-eeeeeeee-9cff-080027b1c126 true VMFS-5 10468982784 9545187328
&lt;/code>&lt;/pre>
&lt;p>We are now ready to create VM.&lt;/p>
&lt;h2 id="dummy-virtual-machine">Dummy virtual machine&lt;/h2>
&lt;p>Sometimes, you may need to have empty, but working, virtual machines for testing. The following command create a dummy VM named &lt;em>TestVM&lt;/em> and stored on the local datastore:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/createdummyvm testVM [LocalDatastore_001]/testVM/testVM.vmx
1
&lt;/code>&lt;/pre>
&lt;p>Checking:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/getallvms
Vmid Name File Guest OS Version Annotation
1 testVM [LocalDatastore_001] testVM/testVM.vmx otherGuest vmx-10
&lt;/code>&lt;/pre>
&lt;p>Houra !&lt;/p>
&lt;p>Now we can play with this VM:&lt;/p>
&lt;p>Starting the VM:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/power.on 1
Powering on VM:
&lt;/code>&lt;/pre>
&lt;p>Get runtime informations about the running VM:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/get.runtime 1
Runtime information
(vim.vm.RuntimeInfo) {
dynamicType = &amp;lt;unset&amp;gt;,
host = 'vim.HostSystem:ha-host',
connectionState = &amp;quot;connected&amp;quot;,
powerState = &amp;quot;poweredOn&amp;quot;,
faultToleranceState = &amp;quot;notConfigured&amp;quot;,
dasVmProtection = (vim.vm.RuntimeInfo.DasProtectionState) null,
toolsInstallerMounted = false,
suspendTime = &amp;lt;unset&amp;gt;,
bootTime = &amp;quot;2015-02-04T00:28:55.507435Z&amp;quot;,
suspendInterval = 0,
question = (vim.vm.QuestionInfo) null,
memoryOverhead = 36478976,
maxCpuUsage = 2496,
maxMemoryUsage = 32,
numMksConnections = 0,
recordReplayState = &amp;quot;inactive&amp;quot;,
cleanPowerOff = &amp;lt;unset&amp;gt;,
needSecondaryReason = &amp;lt;unset&amp;gt;,
onlineStandby = false,
minRequiredEVCModeKey = &amp;lt;unset&amp;gt;,
consolidationNeeded = false,
featureRequirement = (vim.vm.FeatureRequirement) [
(vim.vm.FeatureRequirement) {
dynamicType = &amp;lt;unset&amp;gt;,
key = &amp;quot;cpuid.SSE3&amp;quot;,
featureName = &amp;quot;cpuid.SSE3&amp;quot;,
value = &amp;quot;Bool:Min:1&amp;quot;,
},
(vim.vm.FeatureRequirement) {
dynamicType = &amp;lt;unset&amp;gt;,
key = &amp;quot;cpuid.SSSE3&amp;quot;,
featureName = &amp;quot;cpuid.SSSE3&amp;quot;,
value = &amp;quot;Bool:Min:1&amp;quot;,
},
(vim.vm.FeatureRequirement) {
dynamicType = &amp;lt;unset&amp;gt;,
key = &amp;quot;cpuid.NX&amp;quot;,
featureName = &amp;quot;cpuid.NX&amp;quot;,
value = &amp;quot;Bool:Min:1&amp;quot;,
},
(vim.vm.FeatureRequirement) {
dynamicType = &amp;lt;unset&amp;gt;,
key = &amp;quot;cpuid.RDTSCP&amp;quot;,
featureName = &amp;quot;cpuid.RDTSCP&amp;quot;,
value = &amp;quot;Bool:Min:1&amp;quot;,
},
(vim.vm.FeatureRequirement) {
dynamicType = &amp;lt;unset&amp;gt;,
key = &amp;quot;cpuid.Intel&amp;quot;,
featureName = &amp;quot;cpuid.Intel&amp;quot;,
value = &amp;quot;Bool:Min:1&amp;quot;,
}
],
vFlashCacheAllocation = 0,
}
&lt;/code>&lt;/pre>
&lt;p>Power-off:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/power.off 1
Powering off VM:
&lt;/code>&lt;/pre>
&lt;p>Get informations about the datastore location of VM:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/get.datastores 1
name LocalDatastore_001
url /vmfs/volumes/54d15e2c-eeeeeeee-9cff-080027b1c126
capacity 10468982784
freeSpace 9544138752
accessible 1
type VMFS
multipleHostAccess &amp;lt;unset&amp;gt;
&lt;/code>&lt;/pre>
&lt;h2 id="imported-virtual-machine">Imported virtual machine&lt;/h2>
&lt;p>A dummy VM is usefull to test ESXi command line tools, but in some case you may want to test more complex VM settings. In that case, you can import an existing VM to your ESXi and run it.&lt;/p>
&lt;h3 id="prerequisites">Prerequisites&lt;/h3>
&lt;p>Create a virtual machine on virtual box with :&lt;/p>
&lt;ul>
&lt;li>SCSI/LsiLogic controller for main storage&lt;/li>
&lt;li>Bridged network connection (keep in mind the used mac address)&lt;/li>
&lt;li>Fixed IP settings&lt;/li>
&lt;/ul>
&lt;p>You'll also need the ovftools installed on your system: &lt;a href="https://www.vmware.com/support/developer/ovf/" title="Install OVFtools">see instructions on VMware website&lt;/a>&lt;/p>
&lt;h3 id="export">Export&lt;/h3>
&lt;p>To export a virtual machine on virtualbox you can use the File/Export menu or the following command line:&lt;/p>
&lt;pre>&lt;code>$ vboxmanage export CentosTest -o CentosTest.ova
0%...10%...
&lt;/code>&lt;/pre>
&lt;p>Next operation is to convert the .ova file to a &lt;code>.vmx&lt;/code> one that can be used on ESXi:&lt;/p>
&lt;pre>&lt;code>$ ovftool --lax CentosTest.ova CentosTest.vmx
Opening OVA source: CentosTest.ova
Opening VMX target: CentosTest.vmx
Warning:
- Line 25: Unsupported hardware family 'virtualbox-2.2'.
Writing VMX file: CentosTest.vmx
Transfer Completed
Warning:
- No manifest entry found for: 'CentosTest-disk1.vmdk'.
- No manifest file found.
Completed successfully
&lt;/code>&lt;/pre>
&lt;p>Now we have a &lt;code>.vmx&lt;/code> and its &lt;code>.vmdk&lt;/code> file:&lt;/p>
&lt;pre>&lt;code>$ du -ch *
976M CentosTest-disk1.vmdk
402M CentosTest.ova
12K CentosTest.vmx
1,4G total
&lt;/code>&lt;/pre>
&lt;h3 id="import">Import&lt;/h3>
&lt;p>To import the vmx&amp;amp;vmdk file as a VM to our nested ESXi we also use the ovftool:&lt;/p>
&lt;pre>&lt;code>$ ovftool \
--name=&amp;quot;CentosTest&amp;quot; \
-dm=thin -ds=LocalDatastore_001 \
--net:&amp;quot;bridged&amp;quot;=&amp;quot;VM Network&amp;quot; \
CentosTest.vmx vi://root@192.168.1.16/
Opening VMX source: CentosTest.vmx
Enter login information for target vi://192.168.1.16/
Username: root
Password: *********
Opening VI target: vi://root@192.168.1.16:443/
Warning:
- The specified operating system identifier '' (id: 79) is not supported on the selected host. It will be mapped to the following OS identifier: 'Other Linux (32-bit)'.
Deploying to VI: vi://root@192.168.1.16:443/
Transfer Completed
Completed successfully
&lt;/code>&lt;/pre>
&lt;p>This command will import the virtual machine on ESXi with following settings:&lt;/p>
&lt;ul>
&lt;li>&lt;code>-dm=thin&lt;/code> : force to use thin provisioning method for disk&lt;/li>
&lt;li>&lt;code>-ds=LocalDatastore_001&lt;/code> : target datastore&lt;/li>
&lt;li>&lt;code>--net:&amp;quot;bridged&amp;quot;=&amp;quot;VM Network&amp;quot;&lt;/code> : Map the bridged network to the &lt;code>VM Network&lt;/code> one on ESXi&lt;/li>
&lt;/ul>
&lt;p>We can check the import from the ESXi shell:&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/getallvms
Vmid Name File Guest OS Version Annotation
2 CentosTest [LocalDatastore_001] CentosTest/CentosTest.vmx otherLinuxGuest vmx-10
&lt;/code>&lt;/pre>
&lt;h3 id="enable-network-from-nested-vm">Enable network from nested-VM&lt;/h3>
&lt;p>To keep the mac address you already set in virtualBox:&lt;/p>
&lt;pre>&lt;code>$ sed -i &amp;quot;s/ethernet0\.addressType \= \&amp;quot;generated\&amp;quot;/ethernet0\.addressType \= \&amp;quot;static\&amp;quot;/g&amp;quot; /vmfs/volumes/LocalDatastore_001/CentosTest/CentosTest.vmx
echo &amp;quot;ethernet0.address=\&amp;quot;08:00:27:47:76:67\&amp;quot;&amp;quot; &amp;gt;&amp;gt; /vmfs/volumes/LocalDatastore_001/CentosTest/CentosTest.vmx
&lt;/code>&lt;/pre>
&lt;p>If you powerOn the VM now, you'll not be able to join it on the network from another computer than the nested ESXi. This limitation is link to the nested ESXi VM configuration. You'll need to enable &amp;quot;promiscuous mode&amp;quot; on the ESXi VM. By command line:&lt;/p>
&lt;pre>&lt;code>$ vboxmanage controlvm NestedESXi nicpromisc1 allow-all
&lt;/code>&lt;/pre>
&lt;p>With a poweredOn VM On ESXi you should now be able to join the LAN or to join nested VM from LAN too.&lt;/p>
&lt;h2 id="add-vnc-support-to-vm">Add VNC support to VM&lt;/h2>
&lt;p>If you want to be able to get a view or access to virtual machine, you have to setup VNC access on VM and on ESXi firewall.&lt;/p>
&lt;h3 id="vm-setup-for-vnc">VM setup for VNC&lt;/h3>
&lt;p>First step is to edit the VM vmx file to add some informations (&lt;em>VM needs to be powered-off&lt;/em>):&lt;/p>
&lt;pre>&lt;code>$ echo &amp;quot;RemoteDisplay.vnc.enabled = \&amp;quot;true\&amp;quot;
RemoteDisplay.vnc.port = \&amp;quot;5800\&amp;quot;
RemoteDisplay.vnc.password = \&amp;quot;125678\&amp;quot; \
RemoteDisplay.vnc.keymap = \&amp;quot;fr\&amp;quot;&amp;quot; &amp;gt;&amp;gt; /vmfs/volumes/LocalDatastore_001/CentosTest/CentosTest.vmx
&lt;/code>&lt;/pre>
&lt;p>Now we reload VM config file :&lt;/p>
&lt;pre>&lt;code>$ vim-cmd vmsvc/reload 2
&lt;/code>&lt;/pre>
&lt;p>You can start/stop/do-everything-you-want on your newly imported VM !&lt;/p>
&lt;h3 id="firewall-configuration-for-vnc">Firewall configuration for VNC&lt;/h3>
&lt;p>We create a folder on our Datastore to store the FW configuration files:&lt;/p>
&lt;pre>&lt;code>$ mkdir /vmfs/volumes/LocalDatastore_001/firewall/
&lt;/code>&lt;/pre>
&lt;p>And we create our first firewall custom script:&lt;/p>
&lt;pre>&lt;code>$ echo &amp;quot;&amp;lt;!-- Custom firewall configuration information --&amp;gt;
&amp;lt;ConfigRoot&amp;gt;
&amp;lt;!-- VNC --&amp;gt;
&amp;lt;service id='0038'&amp;gt;
&amp;lt;id&amp;gt;VNC&amp;lt;/id&amp;gt;
&amp;lt;rule id='0000'&amp;gt;
&amp;lt;direction&amp;gt;inbound&amp;lt;/direction&amp;gt;
&amp;lt;protocol&amp;gt;tcp&amp;lt;/protocol&amp;gt;
&amp;lt;porttype&amp;gt;dst&amp;lt;/porttype&amp;gt;
&amp;lt;port&amp;gt;
&amp;lt;begin&amp;gt;5800&amp;lt;/begin&amp;gt;
&amp;lt;end&amp;gt;5999&amp;lt;/end&amp;gt;
&amp;lt;/port&amp;gt;
&amp;lt;/rule&amp;gt;
&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
&amp;lt;required&amp;gt;false&amp;lt;/required&amp;gt;
&amp;lt;/service&amp;gt;
&amp;lt;/ConfigRoot&amp;gt;&amp;quot; &amp;gt; /vmfs/volumes/LocalDatastore_001/VPNtoVM.xml
&lt;/code>&lt;/pre>
&lt;p>This will create a new set of rules and rules for opening TCP ports 5800 to 5999 for VNC usage.&lt;/p>
&lt;p>Then we test our configuration file:&lt;/p>
&lt;pre>&lt;code>$ cp /vmfs/volumes/LocalDatastore_001/firewall/*.xml /etc/vmware/firewall/
$ esxcli network firewall refresh
$ esxcli network firewall ruleset list | grep VNC
VNC true
$ esxcli network firewall ruleset rule list | grep VNC
VNC Inbound TCP Dst 1234 1234
&lt;/code>&lt;/pre>
&lt;p>It seems OK but if you reboot the ESXi, these changes will be lost. In order to keep them working, we use the &lt;code>/etc/rc.local.d/local.sh&lt;/code> script to copy and refresh rules on starting process:&lt;/p>
&lt;pre>&lt;code>$ echo &amp;quot;$(cat /etc/rc.local.d/local.sh | grep -v exit)
# Copy custom firewall configurations
cp /vmfs/volumes/LocalDatastore_001/firewall/*.xml /etc/vmware/firewall/
esxcli network firewall refresh
exit 0&amp;quot; &amp;gt; /etc/rc.local.d/local.sh
&lt;/code>&lt;/pre>
&lt;p>And if you need to be more restrictive about the authorized IP address:&lt;/p>
&lt;pre>&lt;code>$ esxcli network firewall ruleset set --allowed-all false --ruleset-id=VNC
$ esxcli network firewall ruleset allowedip add --ip-address=192.168.1.0/24 --ruleset-id=VNC
&lt;/code>&lt;/pre>
&lt;p>... to only accept IP address from a subnet to access to VNC features.&lt;/p>
&lt;p>And you just need a VNC client software to access to your VM console with following settings:&lt;/p>
&lt;ul>
&lt;li>server IP : ip of your nested ESXi&lt;/li>
&lt;li>server port : port you choose for VNC settings on the VM&lt;/li>
&lt;li>password : VNC password on VM settings&lt;/li>
&lt;/ul>
&lt;figure>&lt;img src="vuptime.io/images/NestedVirtualMachine/NestedVirtualMachineVNC.png"/>&lt;figcaption>
&lt;h4>VNC access to a virtual machine&lt;/h4>
&lt;/figcaption>
&lt;/figure></description></item><item><title>PowerCli - Mise à jour du VMX de templates de machines virtuelles</title><link>vuptime.io/post/2021/05/06/vmware-event-broker-on-k8s-with-knative-part2/</link><pubDate>Mon, 12 May 2014 00:00:00 +0000</pubDate><guid>/2014/05/12/powercli-mise-jour-du-vmx-de-templates-de-machines-virtuelles/</guid><description>
&lt;p>Lorsqu'on gère plusieurs centaines de machines virtuelles, templates, virtual-appliance etc., on a pas spécialement envie de se palucher à la main, les opérations de mises-à-jour systématiques. En plus si vous cotoyez des gus comme &lt;a href="https://twitter.com/fdibot" title="Le compte twitter du (gentil) gus en question">@fdibot&lt;/a>, ça devient carrément un sacrilège d'envisager de faire à la main ce genre d'opération, si vous avez la possibilité de le scripter en powershell.&lt;/p>
&lt;p>Si on travaille sur un environnement Windows et VMware, l'API &amp;quot;&lt;a href="https://www.vmware.com/support/developer/PowerCLI/" title="Documentation de PowerCli">PowerCli&lt;/a>&amp;quot; est une facilité appréciable qui permet d'automatiser des tâches fastidieuses à réaliser à la main sur votre infrastructure vSphere. Le dernier exemple en date a été une demande pour modifier, rapidement, les paramètres VMX de templates de machines virtuelles. Or si la lecture de la configuration VMX d'une VM ou d'un template est aisée, l'écriture de modifications sur un template nécessite une petite pirouette que j'explique ici.&lt;/p>
&lt;h1 id="étape-par-étape">Étape par étape&lt;/h1>
&lt;h2 id="se-connecter-à-vcenter">Se connecter à vCenter&lt;/h2>
&lt;p>C'est l'étape la plus simple et la plus documentée sur Internet. Tout commence par l'ajout à votre contexte, du module adéquat qui va vous permettre d'utiliser l'extension &lt;code>PowerCli&lt;/code>:&lt;/p>
&lt;pre>&lt;code># load PowerCli Snapin
if ((Get-PSSnapin -Name VMware.Vimautomation.Core -ErrorAction SilentlyContinue) -eq $null ) {
Add-PsSnapin VMware.Vimautomation.Core
}
&lt;/code>&lt;/pre>
&lt;p>Ensuite on se connecte à notre vCenter Server préféré:&lt;/p>
&lt;pre>&lt;code># vCenter server
$VC = &amp;quot;monvcenter.domain.tld&amp;quot;
$Username = &amp;quot;domain\monuser&amp;quot;
# connecting vCenter
$Credentials = get-credential -credential $Username
Connect-VIServer -server $($VC.IP) -Credential $Credentials
&lt;/code>&lt;/pre>
&lt;h2 id="préparer-la-configuration-à-mettre-en-place">Préparer la configuration à mettre en place&lt;/h2>
&lt;p>Les paramètres d'un fichier VMX sont simplement composés d'un couple clé/valeur. Le type d'objet requis est &lt;code>VMware.Vim.optionvalue&lt;/code>, le tout ajouté à un type d'objet correspondant à la configuration (même partielle) d'une VM: &lt;code>VMware.Vim.VirtualMachineConfigSpec&lt;/code>.&lt;/p>
&lt;pre>&lt;code># config change for updateVMWareTools
$vmConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
$vmConfigSpec.extraconfig += New-Object VMware.Vim.optionvalue
$vmConfigSpec.extraconfig[0].Key=&amp;quot;isolation.tools.guestInitiatedUpgrade.disable&amp;quot;
$vmConfigSpec.extraconfig[0].Value=&amp;quot;false&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Ici on va placer à &amp;quot;vrai&amp;quot; toutes les valeurs (déjà existantes ou pas) de &lt;code>isolation.tools.guestInitiatedUpgrade.disable&lt;/code> (ce qui permettra de lancer la mise à jour des VMwareTools d'une machine, depuis l'OS de la VM).&lt;/p>
&lt;h2 id="appliquer-cette-modification-aux-templates">Appliquer cette modification aux templates&lt;/h2>
&lt;p>Dans le cas figure présenté ici, on ne va pas filtrer les templates sur lesquels appliquer ce changement de configuration. Il est toutefois envisageable de placer un filtre (via &lt;code>| filter&lt;/code>) ou de placer des tests &lt;code>if&lt;/code> pour, par exemple, ne sélectionner que les templates dont le &lt;code>GuestOS&lt;/code> déclaré est de type Windows.&lt;/p>
&lt;pre>&lt;code># update all templates
$templates = Get-template
foreach ($tpl in $templates) {
Write-host -foreground blue &amp;quot;Template: $($tpl.Name)&amp;quot;
Write-host -foreground gray &amp;quot; Converting to VM&amp;quot;
$vm = **Set-Template -Template $tpl -ToVM**
Write-host -foreground gray &amp;quot; updating VMX&amp;quot;
($vm | Get-View).ReconfigVM($vmConfigSpec)
Write-host -foreground gray &amp;quot; Converting to Template back&amp;quot;
**($vm | Get-View).MarkAsTemplate()** | Out-Null
Write-host -foreground gray &amp;quot;End of update process&amp;quot;process
}
&lt;/code>&lt;/pre>
&lt;p>L'astuce, si on peut appeler ça ainsi, est de réaliser la séquence suivante pour chaque template:&lt;/p>
&lt;ol>
&lt;li>conversion en machine virtuelle&lt;/li>
&lt;li>mise à jour du VMX&lt;/li>
&lt;li>conversion en template&lt;/li>
&lt;/ol>
&lt;p>C'est moche mais c'est rapide et ça fait bien le job.&lt;/p>
&lt;h2 id="quand-cest-terminé">Quand c'est terminé&lt;/h2>
&lt;p>On se déconnecte:&lt;/p>
&lt;pre>&lt;code># clean leave
Disconnect-VIServer -Confirm:$false
&lt;/code>&lt;/pre>
&lt;p>That's all folks !&lt;/p>
&lt;h1 id="la-version-complète">La version complète&lt;/h1>
&lt;p>La version complète du script présenté ici est disponible ici: &lt;a href="https://gist.github.com/lrivallain/b74a87c5c01a53ee242f#file-templatesvmxupdater-ps1" title="Le script sur mon profil github/gist">lrivallain &lt;em>(sur Github)&lt;/em> / TemplatesVmxUpdater.ps1&lt;/a>&lt;/p>
&lt;p>Et si certains ont trouvé plus rapide et moins sale, les commentaires sont là pour ça.&lt;/p></description></item></channel></rss>